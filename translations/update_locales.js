const fs = require('fs');
const token = process.env.TRANSIFEX_TOKEN;
var org = process.env.TRANSIFEX_ORG;
var project = process.env.TRANSIFEX_PROJECT;
var resource = process.env.TRANSIFEX_RESOURCE;

const options = {
    method: 'GET',
    headers: {
        accept: 'application/vnd.api+json',
        authorization: `Bearer ${token}`
    }
};

const updateLocales = async () => {
    return new Promise((res, rej) => {
        fetch(`https://rest.api.transifex.com/projects/o%3A${org}%3Ap%3A${project}/languages`, options)
            .then(response => response.json())
            .then(async (response) => {
                const locales = [];
                const languages = response.data.map(lang => ({
                    name: lang.attributes.name,
                    code: lang.attributes.code
                }));

                const fetchPromises = languages.map(lang => {
                    return fetch(`https://rest.api.transifex.com/resource_language_stats/o%3A${org}%3Ap%3A${project}%3Ar%3A${resource}%3Al%3A${lang.code}`, options)
                        .then(response => response.json())
                        .then(response => {
                            if (response.data.type == 'resource_language_stats' && 
                                ((response.data.attributes.translated_strings / response.data.attributes.total_strings) > 0.25)) {
                                locales.push(lang.code);
                            } else {
                                languages.splice(languages.indexOf(lang), 1);
                            }
                        });
                });

                await Promise.all(fetchPromises);

                // Transifex doesn't let you download your source file
                languages.push({
                    name: 'English',
                    code: 'en'
                });

                const localesContent = `//AUTOMATICALLY GENERATED BY update_locales.js\nmodule.exports = ${JSON.stringify(languages)};`;
                fs.writeFileSync('./translations/locales.js', localesContent);
                res(locales);
            })
            .catch(err => {
                console.error(err)
                rej(err);
            });
    });
}

const requestTranslationFile = async (lang) => {
    const postOptions = {
        method: 'POST',
        headers: {
            accept: 'application/vnd.api+json',
            'content-type': 'application/vnd.api+json',
            authorization: `Bearer ${token}`
        },
        body: `{"data":{"attributes":{"callback_url":null,"content_encoding":"text","file_type":"default","mode":"default","pseudo":false},"relationships":{"language":{"data":{"type":"languages","id":"l:${lang}"}},"resource":{"data":{"type":"resources","id":"o:${org}:p:${project}:r:${resource}"}}},"type":"resource_translations_async_downloads"}}`
    };

    return fetch('https://rest.api.transifex.com/resource_translations_async_downloads', postOptions)
        .then(response => response.json())
        .then(response => response.data.id)
        .catch(err => console.error(err));
}

const monitorDownloadFiles = (downloads) => {
    if (downloads.length !== 0) {
        setTimeout(() => {
            const id = downloads[0][0];
            const lang = downloads[0][1];
            fetch(`https://rest.api.transifex.com/resource_translations_async_downloads/${id}`, options)
                .then(response => response.json())
                // Check if Transifex has finished processing the translation, re-queue if not or cancel if failed
                .then(response => {
                    if (response.data && response.data.attributes && response.data.attributes.status) {
                        if (response.data.attributes.status === 'failed') {
                            throw new Error('Failed to download translation');
                        }
                        else if (response.data.attributes.status === 'pending' || response.data.attributes.status === 'processing') {
                            downloads.push(id);
                            throw new Error('Translation still processing');
                        }
                    }
                    return response;
                })
                // If we've received the actual translation file
                .then(response => {
                    const filePath = `./translations/locales/${lang}.json`;
                    fs.writeFileSync(filePath, JSON.stringify(response));
                })
                .catch(err => console.error(err))
                .finally(() => {
                    downloads.splice(0, 1);
                    if (downloads.length !== 0) {
                        monitorDownloadFiles(downloads);
                    }
                });
        }, 500);
    }
}

const fetchLocales = async (locales) => {
    const downloadIDs = [];
    for (locale of locales) {
        const id = await requestTranslationFile(locale);
        downloadIDs.push([id, locale]);
    }
    monitorDownloadFiles(downloadIDs);
}

if (token, org, project, resource) {
    updateLocales().then((locales) => {
        fetchLocales(locales);
    })
} else {
    throw new Error('Missing environment variables');
}